# 消息和队列的失效时间

官方文档: https://www.rabbitmq.com/ttl.html

RabbitMQ支持为消息和队列设置TTL(Time To Live)，TTL可以作用于单个队列，一组队列，单条消息。

RabbitMQ中有几种失效时间:
* 队列的消息失效时间，通过`x-message-ttl`参数配置
* 单条消息的失效时间，通过消息properties的`expiration`参数配置
* 队列的失效时间，通过`x-expires`配置

## 队列的消息失效时间

只要给队列设置`x-message-ttl`参数，就设定了该队列所有消息的存活时间，时间单位是ms，值必须大于等于0。当消息的TTL到期后，消息会变成一条死信（dead letter）投递到DLX中（如果配置有）或者直接丢弃。

**路由到多个队列的消息在其所在的每个队列中可能会在不同的时间消亡，或者根本不会消亡。一个队列中消息的死亡不会影响其他队列中同一消息的生存期**

> [!Note]
> TTL到期后，消息将不会被消费者接收到，但是，`unacked`状态的消息如果TTL到期是不会受影响的。
> 即TTL不会影响到消费者正在消费的消息，除非消息被requeue重新回到队列。


## 单条消息的失效时间

在`basic.publish`的时候给消息properties指定`expiration`参数就能给这条消息指定TTL，注意，`expiration`的值需要是字符串类型的数字，单位为ms。

**当队列的失效时间和消息的失效时间同时配置的时候，将会以较小值为准。**

> [!Warning]
> RabbitMQ只对处于队头的消息判断是否过期（即不会扫描队列），所以，很可能队列中已存在TTL到期的消息，但是队列并不知情。这会影响队列统计数据的正确性，妨碍队列及时释放资源。


## 队列的失效时间

通过`x-expires`参数配置队列的失效时间，单位为ms。仅当队列没有在使用时，这一失效时间才会生效。

队列未被使用的情况:
* 队列没有被重新申明
* 没有`basic.get`操作发生
* 没有Consumer连接在队列上

> [!Note]
> 即使队列没有消息能被消费，只要有消费者连接，就算是在使用；即使一直有消息推送到队列，只有没有消费者连接，就不算在使用。
