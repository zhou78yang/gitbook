# 并发控制
只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。MySQL通常从两个层面控制并发：服务器层和存储引擎层。

## 读写锁
* 读锁（read lock）/共享锁（shared lock）：其他事务可以读，但不能写
* 写锁（write lock）/排它锁（exclusive lock）：其他事务不可以读，也不能写

读锁是共享的，或者说是互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。
写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，
只有这样，才能确保在给定的时间里，只能一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

## 锁粒度
MySQL不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：

* 行级锁（row-level lock）：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 表锁（table lock）：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

默认情况下，表锁和行锁都是自动获得的，不需要额外的命令。

但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制，以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。

## 多版本并发控制(MVCC)
MySQL的大部分存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC），
但各自的实现机制并不相同，MVCC并没有一个统一的标准.

MVCC是行级锁的一个变种，但是它在很多情况下都避免了加锁这一操作，因此开销更低。

MVCC的实现，是通过保存数据在某个时间点的快照（snapshot）来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。
根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

## InnoDB的MVCC简化说明
InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列分别保存了行的**创建时间**和**删除时间**（其中存储的不是真实的时间，而是系统版本号，system version number）。
每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
在`REPEATABLE READ`隔离级别下，MVCC具体操作：

##### SELECT
InnoDB会根据以下两个条件检查每行记录：
* InnoDB只查找版本号早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。
* 行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除
只有符合上述两个条件的记录，才能返回作为查询结果。

##### INSERT
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

##### DELETE
InnoDB为删除的每一行保存当前系统版本号作为行删除标记。

##### UPDATE
InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标记。

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。
不足之处就是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

MVCC只在`REPEATABLE READ`和`READ COMMITTED`两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。
因为`READ UNCOMMITTED`总是读取最新的数据行，而不是符合当前事务版本的数据行，`SERIALIZABLE`总会对所有读取的行加锁。

